"""
This module provides the XMLValidator class used to validate structured XML content
generated by an LLM. The XML must conform to a predefined schema using specific 
tags and attributes.

The validator ensures:
- Correct tag hierarchy
- Required attributes per tag
- Attribute values and delay formats
- XML syntax and structure
"""

from lxml import etree
import re

class XMLValidator:
    """
    Validates structured XML content for properties and events used in scenario definitions.
    """
    def __init__(self):
        """
        Initialize validation rule for tags, attributes, and embedding rules.
        """
        self.VALID_TAGS = {"beginning", "property", "event", "embedded_functions", "operator"}
        self.VALID_ATTRIBUTES = {
            "property": {"value", "delay_min", "delay_max", "property_id", "description", "type_property", "if_violated", "if_satisfied", "delay_units"},
            "event": {"value", "event_id", "description", "boolean_expression"},
            "operator": {"value", "delay_units", "delay_min", "delay_max"}
        }
        self.REQUIRED_ATTRIBUTES = {
            "property": {"property_id", "description", "type_property"},
            "event": {"value", "event_id", "description", "boolean_expression"}
        }
        self.EMBEDDED_TAGS = {
            "beginning": {"property", "embedded_functions"},
            "property": {"event", "operator"},
            "operator": {"event"}
        }

    def validate_delay(self, value):
        """
        Validates that a delay value follows accepted formats.

        Args:
            value (str): The delay value (e.g., "2", "-1", "5+", "-3+").
        
        Returns:
            bool: True if valid, False otherwise.   
        """
        if re.fullmatch(r"-?\d+|\d+\+", value):
            return True
        return False

    def validate_property_attributes(self, prop):
        """
        Validates the attributes of a <property> tag.

        Args:
            prop (etree.Element): The <property> XML element to validate.
        
        Returns:
            (bool, str): Tuple indicating if the validation passed and an optional error message.
        """
        for attr in prop.attrib:
            if attr not in self.VALID_ATTRIBUTES["property"]:
                message = f"Invalid attribute {attr} in property tag"
                return False, message
        
        if not all(attr in prop.attrib for attr in self.REQUIRED_ATTRIBUTES["property"]):
            message = "Missing required attributes in property tag"
            return False, message
        
        if prop.attrib["type_property"] not in {"ATTACK", "SECURITY_RULE", "EVASION", "SECURITY", "TEST"}:
            message = "Invalid type_property attribute in property tag"
            return False, message
        
        if "value" in prop.attrib and prop.attrib["value"] not in {"THEN", "COMPUTE"}:
            message = "Invalid value attribute in property tag"
            return False, message

        if "delay_min" in prop.attrib and not self.validate_delay(prop.attrib["delay_min"]):
            message = "Invalid delay_min attribute in property tag"
            return False, message
        
        if "delay_max" in prop.attrib and not self.validate_delay(prop.attrib["delay_max"]):
            message = "Invalid delay_max attribute in property tag"
            return False, message
        return True, ""
    
    def validate_operator_attributes(self, operator):
        """
        Validates the attributes of an <operator> tag.

        Args:
            operator (etree.Element): The <operator> XML element to validate.
        
        Returns:
            (bool, str): Tuple indicating if the validation passed and an optional error message.
        """
        if not all(attr in self.VALID_ATTRIBUTES["operator"] for attr in operator.attrib):
            message = "Invalid attribute in operator tag"
            return False, message
        
        if "value" in operator.attrib and operator.attrib["value"] not in {"THEN", "COMPUTE"}:
            message = "Invalid value attribute in operator tag"
            return False, message
        
        if "delay_min" in operator.attrib and not self.validate_delay(operator.attrib["delay_min"]):
            message = "Invalid delay_min attribute in operator tag"
            return False, message
        
        if "delay_max" in operator.attrib and not self.validate_delay(operator.attrib["delay_max"]):
            message = "Invalid delay_max attribute in operator tag"
            return False, message
        return True, ""
    
    def validate_allowed_tags(self, element, parent_tag):
        """
        Ensures a given element only contains allowed child tags.

        Args:
            element (etree.Element): The parent XML element.
            parent_tag (str): The tag name of the parent element.
        
        Returns:
            (bool, str): Tuple indicating if the validation passed and an optional error message.
        """
        allowed_tags = self.EMBEDDED_TAGS[parent_tag]
        for child in element:
            if isinstance(child, etree._Comment):
                continue # Skip comments
            if child.tag not in allowed_tags:
                message = f"Invalid tag {child.tag} inside {parent_tag}"
                return False, message
        return True, ""
    
        
    def validate_event(self, event):
        """
        Validates an <event> tag for proper structure and attributes.

        Args:
            event (etree.Element): The <event> XML element to validate.
        
        Returns:
            (bool, str): Tuple indicating if the validation passed and an optional error message.
        """
        # An event shouldn't have any children
        if len(list(event)) > 0:
            message = "Event tag should not have children tags"
            return False, message
        
        # Check event valid attributes
        if not all(attr in self.VALID_ATTRIBUTES["event"] for attr in event.attrib):
            message = "Invalid attribute in event tag"
            return False, message
        
        # Check required attributes
        if not all(attr in event.attrib for attr in self.REQUIRED_ATTRIBUTES["event"]):
            message = "Missing required attributes in event tag"
            return False, message
        
        if event.attrib["value"] not in {"COMPUTE"}:
            message = "Invalid value attribute in event tag"
            return False, message
        
        # Check boolean expression
        if "boolean_expression" not in event.attrib:
            message = "Missing boolean_expression attribute in event tag"
            return False, message

        return True, ""
        
    
    def validate_xml(self, xml_buffer):
        """
        Validates the entire XML string for structured content.

        Args:
            xml_buffer (str): The XML content to validate.
        
        Returns:
            (bool, str): Tuple indicating if the validation passed and an optional error message.
        """
        # Check xml_buffer of type str
        if not isinstance(xml_buffer, str):
            message = "XML is not a string"
            return False, message
        
        self.xml_buffer = xml_buffer
        message = ""
        try:
            root = etree.fromstring(self.xml_buffer)

            # Validate root element
            if root.tag != "beginning":
                message = "Root tag is not 'beginning'"
                return False, message
            if root.attrib: # Validate beginning tag without attributes
                message = "Beggining tag has attributes"
                return False, message
            # Not other elements inside <beginning> tag
            is_valid, message = self.validate_allowed_tags(root, "beginning")
            if not is_valid:
                return is_valid, message

            # Validate <property> tags
            properties = root.findall("property")

            if not properties:
                message = "No property tags found"
                return False, message
            
            for prop in properties:
                #Check property tag attributes
                is_valid, message = self.validate_property_attributes(prop)
                if not is_valid:
                    return is_valid, message
                
                # Check embedded tags inside property
                is_valid, message = self.validate_allowed_tags(prop, "property")
                if not is_valid:
                    return is_valid, message

                # Check property children tags
                for child in prop:
                    if child.tag == "operator":
                        # Check operator allowed tags
                        is_valid, message = self.validate_allowed_tags(child, "operator")
                        if not is_valid:
                            return is_valid, message
                        
                        # Check operator attributes
                        is_valid, message = self.validate_operator_attributes(child)
                        if not is_valid:
                            return is_valid, message

                        # If operator has event tag, check event
                        for event in child:
                            is_valid, message = self.validate_event(event)
                            if not is_valid:
                                return is_valid, message
                   
                    # Check event tag
                    elif child.tag == "event":
                        is_valid, message = self.validate_event(child)
                        if not is_valid:
                            return is_valid, message
                
        except etree.XMLSyntaxError:
            message = "Invalid XML syntax"
            return False, message
        return True, "XML is valid"